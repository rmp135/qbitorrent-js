export function MapMainDataResponse (response: MainDataResponse): MainData {
  return {
    server_state: {
      alltime_download: response.server_state.alltime_dl,
      alltime_upload: response.server_state.alltime_ul,
      average_queue_time: response.server_state.average_time_queue,
      connection_status: response.server_state.connection_status,
      dht_nodes: response.server_state.dht_nodes,
      download_data: response.server_state.dl_info_data,
      download_speed: response.server_state.dl_info_speed,
      download_rate_limit: response.server_state.dl_rate_limit,
      global_ratio: response.server_state.global_ratio,
      queued_io_jobs: response.server_state.queued_io_jobs,
      queuing: response.server_state.queuing,
      read_cache_hits: response.server_state.read_cache_hits,
      refresh_interval: response.server_state.refresh_interval,
      total_buffers_size: response.server_state.total_buffers_size,
      total_peer_connections: response.server_state.total_peer_connections,
      total_queued_size: response.server_state.total_queued_size,
      total_wasted_data: response.server_state.total_wasted_data,
      upload_data: response.server_state.up_info_data,
      upload_speed: response.server_state.up_info_speed,
      upload_rate_limit: response.server_state.up_rate_limit,
      upload_alt_speed_limits: response.server_state.up_alt_speed_limits,
      write_cache_overload: response.server_state.write_cache_overload
    },
    categories: response.categories,
    torrents: Object.keys(response.torrents).map(t => ({
      id: t,
      added_on: new Date(response.torrents[t].added_on),
      amount_left: response.torrents[t].amount_left,
      auto_tmm: response.torrents[t].auto_tmm,
      category: response.torrents[t].category,
      completed: response.torrents[t].completed,
      completed_on: new Date(response.torrents[t].amount_left),
      download_limit: response.torrents[t].dl_limit,
      download_speed: response.torrents[t].dlspeed,
      downloaded: response.torrents[t].downloaded,
      downloaded_session: response.torrents[t].downloaded_session,
      eta: new Date(response.torrents[t].eta),
      f_l_piece_prio: response.torrents[t].f_l_piece_prio,
      force_start: response.torrents[t].force_start,
      last_activity: new Date(response.torrents[t].last_activity),
      magnet_url: response.torrents[t].magnet_url,
      name: response.torrents[t].name,
      num_complete: response.torrents[t].num_complete,
      num_incomplete: response.torrents[t].num_incomplete,
      leeches: response.torrents[t].num_leechs,
      seeds: response.torrents[t].num_seeds,
      priority: response.torrents[t].priority,
      progress: response.torrents[t].progress,
      ratio: response.torrents[t].ratio,
      ratio_limit: response.torrents[t].ratio_limit,
      save_path: response.torrents[t].save_path,
      seen_complete: response.torrents[t].seen_complete,
      sequential_download: response.torrents[t].seq_dl,
      size: response.torrents[t].size,
      state: response.torrents[t].state,
      super_seeding: response.torrents[t].super_seeeding,
      total_size: response.torrents[t].total_size,
      tracker: response.torrents[t].tracker,
      upload_limit: response.torrents[t].up_limit,
      uploaded: response.torrents[t].uploaded,
      uploaded_session: response.torrents[t].uploaded_session,
      upload_speed: response.torrents[t].upspeed,
    }))
  }
}